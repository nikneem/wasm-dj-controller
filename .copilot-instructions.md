# Copilot Instructions for WASM DJ Controller

## Project Overview
WASM DJ Controller is a high-performance, browser-based DJ mixing application built with Angular frontend and WebAssembly audio processing engine. The project enables real-time audio playback with tempo control, pitch detection, BPM analysis, and harmonic mixing capabilities.

## Core Architecture

### Technology Stack
- **Frontend UI**: Angular (TypeScript)
- **UI Components**: PrimeNG (PrimeFaces) component library
- **Audio Engine**: WebAssembly (Rust/C++)
- **Audio API**: Web Audio API, AudioWorklet
- **Threading Model**: Web Workers for background processing
- **Build System**: Cargo (Rust) + Angular CLI

### Key Components
1. **Angular UI Layer** (`src/frontend/`)
   - Virtual decks display
   - Control sliders (pitch, tempo, crossfader)
   - BPM counter and beat grid visualization
   - Waveform visualization
   - Track selection and loading UI

2. **WASM Audio Engine** (`src/audio-engine/`)
   - MP3 decoding (FFmpeg-based)
   - Phase Vocoder for time-stretching
   - Pitch-shifting algorithms
   - BPM/rhythm detection (spectral flux, onset detection)
   - Pitch/key detection (chroma vector analysis)

3. **Web Audio API Integration** (`src/web-audio/`)
   - AudioWorklet processor for Wasm integration
   - Audio graph routing (dual deck mixing)
   - Crossfader implementation
   - AnalyserNode for real-time frequency analysis

4. **Worker Threads** (`src/workers/`)
   - BPM analysis worker (background track analysis)
   - Control message routing between UI and AudioWorklet

## Priority Principles

### ðŸŽ¯ Priority 1: Audio Playback Stability
**No hiccups, no glitches. Audio playback is sacred.**

- All audio processing must run in AudioWorklet (dedicated thread)
- Real-time constraints are non-negotiable
- Never block the audio thread with I/O operations
- Test on low-end hardware to ensure reliability
- Monitor buffer underruns and handle gracefully

### ðŸŽ¯ Priority 2: Low-Latency Control Response
- UI input (slider adjustments) must feel instantaneous
- Pitch/tempo changes should respond in <50ms
- Use Worker threads to offload heavy analysis from main thread

### ðŸŽ¯ Priority 3: User Experience
- Smooth, professional-looking UI
- Real-time visual feedback
- Responsive animations that don't interfere with audio

## Project Structure

```
src/
â”œâ”€â”€ audio-engine/          # Rust/C++ WebAssembly module
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs        # Main Wasm entry point
â”‚   â”‚   â”œâ”€â”€ decoder.rs    # MP3 decoding wrapper
â”‚   â”‚   â”œâ”€â”€ phase_vocoder.rs  # Time-stretching algorithm
â”‚   â”‚   â”œâ”€â”€ pitch_shift.rs    # Pitch-shifting algorithm
â”‚   â”‚   â”œâ”€â”€ bpm_detection.rs  # BPM and rhythm analysis
â”‚   â”‚   â”œâ”€â”€ key_detection.rs  # Pitch/key detection
â”‚   â”‚   â””â”€â”€ filters.rs    # DSP filters and utilities
â”‚   â””â”€â”€ wasm-pack.toml
â”œâ”€â”€ frontend/              # Angular application (using PrimeNG)
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ deck/        # Deck (left/right) - using PrimeNG Card, Button
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ crossfader/  # Crossfader control - using PrimeNG Slider
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ deck-controls/ # Pitch/tempo sliders - using PrimeNG Slider, Knob
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ waveform/    # Waveform display - custom Canvas with PrimeNG Panel
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ status-bar/  # BPM and key info - using PrimeNG Toolbar
â”‚   â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ audio.service.ts    # AudioContext management
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ audio-worklet.service.ts  # AudioWorklet control
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ track-loader.service.ts   # File loading
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ui-sync.service.ts # UIâ†”Audio sync
â”‚   â”‚   â”‚   â””â”€â”€ models/
â”‚   â”‚   â”‚       â”œâ”€â”€ deck.model.ts
â”‚   â”‚   â”‚       â”œâ”€â”€ track.model.ts
â”‚   â”‚   â”‚       â””â”€â”€ audio-state.model.ts
â”‚   â”‚   â””â”€â”€ assets/
â”‚   â”‚       â””â”€â”€ audio-worklet-processor.ts  # AudioWorklet script
â”‚   â”œâ”€â”€ angular.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â””â”€â”€ package.json
â””â”€â”€ workers/               # Web Worker scripts
    â”œâ”€â”€ bpm-analyzer-worker.ts
    â””â”€â”€ track-processor-worker.ts
```

## Development Workflow

### 1. Audio Engine Development (Rust/Wasm)
```bash
cd src/audio-engine
wasm-pack build --target web
```

### 2. Frontend Development (Angular)
```bash
cd src/dj-controller
ng build --configuration development
```
**Note**: Assume `ng serve` is already running in the background on port 4200 or 4300. After making changes:
1. Verify changes compile successfully with `ng build --configuration development`
2. The dev server will automatically reload the application if running
3. Do NOT execute `ng serve` manually - it should remain running throughout the development session

### 3. Integration Testing
- Test audio playback on real devices (including low-end devices)
- Monitor for buffer underruns via Web Audio API timing data
- Profile Wasm module performance with DevTools

## Critical Implementation Guidelines

### Audio Thread Safety
- AudioWorklet runs in a separate thread; assume no shared memory without explicit synchronization
- Use MessagePort for communication between main thread and AudioWorklet
- Never access DOM or Angular state from within AudioWorklet

### Real-Time Constraints
- AudioWorklet processes ~128-512 samples per callback (varies by browser)
- At 48kHz sample rate, this is ~2.6-10.6ms per callback
- Phase Vocoder FFT must complete within callback window
- Pre-allocate buffers; avoid dynamic allocation in the audio path

### Wasm Integration
- Import Wasm functions as ES6 modules in TypeScript
- Use `wasm-bindgen` for Rust â†” JS interop
- Pass audio data as typed arrays (Float32Array) for zero-copy performance
- Minimize serialization overhead between JS and Wasm

### Performance Monitoring
- Log buffer state (current size, max capacity) continuously
- Track Wasm function execution time
- Monitor main thread frame time (60fps target)
- Create performance dashboard in UI

## Feature Specifications

### Deck Operations
- **Load Track**: Decode MP3, extract PCM via Wasm, analyze BPM/key
- **Play/Pause**: Manage AudioBufferSourceNode
- **Tempo Adjustment**: Range -20% to +20% via Phase Vocoder
- **Pitch Adjustment**: Range Â±2 semitones via pitch-shifting
- **Volume/Gain**: GainNode per deck, crossfader for mixing

### Beat Matching
- Real-time BPM display for both decks
- Visual beat grid aligned to detected tempo
- Tempo sync button to match deck 1 to deck 2
- Beatgrid adjustment slider for manual fine-tuning

### Harmonic Mixing
- Key detection on track load (major/minor key, root note)
- Camelot wheel visualization
- Compatible key suggestions
- Pitch lock (key lock) mode to maintain key while tempo matching

### Crossfader
- Linear or curved response option
- Real-time level monitoring (left/center/right)
- Visual feedback of mix point

## Testing Strategy

### Unit Tests
- Wasm algorithms (FFT, phase vocoder, BPM detection)
- Angular services and components
- Worker thread communication

### Integration Tests
- Audio playback stability across 5+ minute tracks
- Tempo/pitch changes without artifacts
- UI responsiveness during heavy audio processing
- Cross-browser compatibility (Chrome, Firefox, Safari)

### Performance Tests
- Measure phase vocoder latency
- Verify zero buffer underruns during normal operation
- Profile Wasm memory usage
- UI frame rate consistency (60fps)

## Browser Compatibility
- Chrome/Chromium 86+ (AudioWorklet support required)
- Firefox 76+ (AudioWorklet support required)
- Safari 14.1+ (AudioWorklet support, limited Wasm features)
- Edge 86+ (Chromium-based)

## Code Style & Best Practices

### Rust (Audio Engine)
- Use SIMD when possible (packed_simd, or platform-specific)
- Minimize allocations in hot paths (pre-allocate buffers)
- Use `no_std` where possible for performance
- Document all public APIs with examples

### TypeScript (Angular)
- Strict type checking enabled
- RxJS observables for state management
- Service-based architecture for audio control
- Component communication via services, not parent-child props for large changes

### PrimeNG Component Guidelines
- Use PrimeNG components consistently throughout the UI
- Prefer PrimeNG components over custom implementations for standard controls
- Common components to use:
  - **Slider** (`p-slider`) - for tempo, pitch, crossfader, EQ controls
  - **Knob** (`p-knob`) - for volume/gain controls (rotary knob UI)
  - **Button** (`p-button`) - for play/pause, cue, load track actions
  - **Card** (`p-card`) - for deck containers and grouping
  - **Toolbar** (`p-toolbar`) - for status bar and top navigation
  - **Panel** (`p-panel`) - for collapsible sections (EQ, effects)
  - **FileUpload** (`p-fileUpload`) - for track loading
  - **ProgressBar** (`p-progressBar`) - for track position/loading
  - **Menu** (`p-menu`) - for context menus and options
- Apply PrimeNG themes consistently (use @primeuix/themes)
- Leverage PrimeNG's responsive utilities for mobile support

### Error Handling
- Audio errors must not crash the app; fallback to safe state
- Log errors for debugging but provide user-friendly messages
- Implement automatic recovery mechanisms (reconnect to AudioContext)

## Known Limitations & Future Improvements

### Current Scope
- Single MP3 format support (extensible to FLAC, WAV)
- Two-deck mixing only (extensible to N decks)
- Phase Vocoder latency ~50-100ms (acceptable for DJ use)

### Future Enhancements
- Loop recording and playback
- Hot-cue support (instant playback from marked points)
- FX chains (reverb, echo, filters)
- MIDI controller input support
- Multi-deck mixing (4+ decks)
- Streaming track support

## References & Resources

- [Web Audio API MDN Docs](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)
- [AudioWorklet Specification](https://www.w3.org/TR/webaudio/#audioworklet)
- [Phase Vocoder Theory](https://en.wikipedia.org/wiki/Phase_vocoder)
- [Essentia.js (BPM Detection)](https://mtg.github.io/essentia.js/)
- [wasm-bindgen Guide](https://rustwasm.org/docs/wasm-bindgen/)

## Getting Help

When working on this project:
1. Consult the architecture docs in `docs/ARCHITECTURE.md`
2. Check implementation guides in `docs/IMPLEMENTATION/`
3. Review test cases for similar features
4. Profile with Chrome DevTools before optimizing

---

**Last Updated**: December 2025  
**Project Status**: Foundation Phase
